"""
AxionDocs - Sistema OCR integrado com API OpenAI
Desenvolvido por Jo√£o Gabriel Santos Barros (2025)

Licenciado sob MIT License - consulte LICENSE.txt

Este software √© fornecido "no estado em que se encontra", sem garantias.

O uso da API OpenAI requer chave configurada via vari√°vel de ambiente: OPENAI_API_KEY.
Os custos gerados s√£o responsabilidade do usu√°rio da chave.

Projeto iniciado como parte do TCC no Cart√≥rio de Registro de Im√≥veis de S√£o Lu√≠s.
"""
# pyright: reportAttributeAccessIssue=false
# Fun√ß√µes para integra√ß√£o com OpenAI/ChatGPT

# (O conte√∫do ser√° movido do app_ocr_melhor.py) 

import openai
import re
import json
from config import Config

def identify_document_type_from_filename(filename):
    """Identifica o tipo do documento baseado no nome do arquivo"""
    if not filename:
        return "DESCONHECIDO"
    
    # Converter para min√∫sculas para compara√ß√£o
    filename_lower = filename.lower()
    
    # Padr√µes de identifica√ß√£o por nome de arquivo
    patterns = {
        'MATR√çCULA': [
            'matricula', 'matr√≠cula', 'matric', 'matricul', 'registro', 'registro_imovel',
            'mat_', 'mat_', 'matricula_', 'matricul_', 'reg_', 'registro_'
        ],
        'CONTRATO': [
            'contrato', 'contract', 'compra', 'venda', 'compra_venda', 'compraevenda',
            'escritura', 'escritura_publica', 'publica', 'contr_', 'contrat_'
        ],
        'ITBI': [
            'itbi', 'imposto', 'transmissao', 'transmiss√£o', 'guia_itbi', 'guia_imposto',
            'certidao_itbi', 'certid√£o_itbi', 'itbi_', 'imposto_'
        ],
        'CERTID√ÉO': [
            'certidao', 'certid√£o', 'certificate', 'cert_', 'certidao_', 'certid√£o_',
            'situacao', 'situa√ß√£o', 'onus', '√¥nus', 'negativa', 'inteiro_teor'
        ],
        'PROCURA√á√ÉO': [
            'procura√ß√£o', 'procura', 'procuracao', 'mandato', 'representacao', 'representa√ß√£o',
            'proc_', 'procur_', 'mandat_', 'represent_'
        ]
    }
    
    # Verificar cada tipo de documento
    for document_type, pattern_list in patterns.items():
        for pattern in pattern_list:
            if pattern in filename_lower:
                print(f"‚úÖ Tipo identificado pelo nome: {document_type} (padr√£o: {pattern})")
                return document_type
    
    # Se n√£o encontrou padr√£o espec√≠fico, retornar DESCONHECIDO
    print(f"‚ö†Ô∏è Nenhum padr√£o encontrado no nome: {filename}")
    return "DESCONHECIDO"

def classify_document_type(text_content, filename="", model="gpt-4o"):
    """Etapa 1: Classifica o tipo do documento usando modelo selecionado com contexto rigoroso"""
    try:
        print(f"üîç Classificando tipo do documento com {model}")
        
        # PRIMEIRA ETAPA: Identifica√ß√£o pelo nome do arquivo
        document_type_from_filename = identify_document_type_from_filename(filename)
        print(f"üìÅ Tipo identificado pelo nome do arquivo: {document_type_from_filename}")
        
        # SEGUNDA ETAPA: Valida√ß√£o e refinamento pela IA
        prompt_classificacao = f"""
üìå CONTEXTO:
Voc√™ √© um Registrador Imobili√°rio com conhecimento profundo da Lei n¬∫ 6.015/1973 (Lei de Registros P√∫blicos), do C√≥digo de Normas do Estado do Maranh√£o (CNCGJ/MA) e das pr√°ticas cartor√°rias nacionais.

Sua tarefa √© **VALIDAR** o tipo do documento identificado pelo nome do arquivo e confirmar se est√° correto.

---

üìÅ INFORMA√á√ïES DISPON√çVEIS:

- Nome do Arquivo: {filename}
- Tipo Identificado pelo Nome: {document_type_from_filename}
- Conte√∫do Extra√≠do do Documento: {text_content}

---

üß† VALIDA√á√ÉO DO TIPO DO DOCUMENTO:

‚ö†Ô∏è **CRIT√âRIOS FUNDAMENTAIS**:
O nome do arquivo indica que este documento √© do tipo: **{document_type_from_filename}**

Sua tarefa √©:
1. **CONFIRMAR** se o tipo identificado pelo nome est√° correto
2. **VALIDAR** se o conte√∫do do documento corresponde ao tipo esperado
3. **CORRIGIR** apenas se houver erro evidente na identifica√ß√£o

---

üîç REGRAS DE VALIDA√á√ÉO DETALHADAS:

1. **MATR√çCULA**: 
   - ESTRUTURA: Documento que cont√©m a descri√ß√£o completa do im√≥vel, propriet√°rios, √¥nus, hist√≥rico de transmiss√µes
   - FUN√á√ÉO: Registro oficial da propriedade imobili√°ria
   - CARACTER√çSTICAS: Cont√©m n√∫mero de matr√≠cula, inscri√ß√£o imobili√°ria, hist√≥rico completo
   - ‚ö†Ô∏è **CR√çTICO**: Mesmo que mencione contratos registrados, certid√µes ou outros documentos, o documento PRINCIPAL √© a matr√≠cula
   - ‚ö†Ô∏è **CR√çTICO**: Se o documento cont√©m hist√≥rico de transmiss√µes, descri√ß√£o do im√≥vel e propriet√°rios ‚Üí √â MATR√çCULA
   - ‚ö†Ô∏è **CR√çTICO**: Se o nome do arquivo cont√©m "matricula" ‚Üí PROVAVELMENTE √â MATR√çCULA

2. **CONTRATO**: 
   - ESTRUTURA: Documento que √© PRINCIPALMENTE um instrumento contratual
   - FUN√á√ÉO: Estabelecer acordo entre partes (compra e venda, cess√£o, financiamento, etc.)
   - CARACTER√çSTICAS: Cont√©m cl√°usulas contratuais, valores, qualifica√ß√£o das partes
   - ‚ö†Ô∏è **CR√çTICO**: N√£o confundir com contratos mencionados dentro de matr√≠culas ou certid√µes
   - ‚ö†Ô∏è **CR√çTICO**: Se o documento √© principalmente um instrumento de acordo entre partes ‚Üí √â CONTRATO
   - ‚ö†Ô∏è **CR√çTICO**: Se o nome do arquivo cont√©m "contrato" ‚Üí PROVAVELMENTE √â CONTRATO

3. **ITBI**: 
   - ESTRUTURA: Documento que √© PRINCIPALMENTE uma guia ou certid√£o de ITBI
   - FUN√á√ÉO: Comprovar pagamento do imposto de transmiss√£o
   - CARACTER√çSTICAS: Cont√©m valores, descri√ß√£o do im√≥vel, dados das partes
   - ‚ö†Ô∏è Focar na fun√ß√£o fiscal/tribut√°ria do documento

4. **CERTID√ÉO**: 
   - ESTRUTURA: Documento que √© PRINCIPALMENTE uma certid√£o de situa√ß√£o jur√≠dica, √¥nus, etc.
   - FUN√á√ÉO: Atestar situa√ß√£o jur√≠dica ou aus√™ncia de √¥nus
   - CARACTER√çSTICAS: Cont√©m data de emiss√£o, prazo de validade, atestado oficial
   - ‚ö†Ô∏è Mesmo que mencione outros documentos, a fun√ß√£o √© atestar situa√ß√£o

5. **PROCURA√á√ÉO**: 
   - ESTRUTURA: Documento que √© PRINCIPALMENTE um instrumento de mandato
   - FUN√á√ÉO: Conceder poderes de representa√ß√£o
   - CARACTER√çSTICAS: Cont√©m outorgante, outorgado, poderes espec√≠ficos
   - ‚ö†Ô∏è Focar na fun√ß√£o de representa√ß√£o legal

---

‚ö†Ô∏è **AN√ÅLISE ESTRUTURAL OBRIGAT√ìRIA**:

1. **PRIMEIRO**: Confirme se o tipo identificado pelo nome est√° correto
2. **SEGUNDO**: Valide se o conte√∫do corresponde ao tipo esperado
3. **TERCEIRO**: Corrija apenas se houver erro evidente
4. **QUARTO**: Baseie-se na natureza jur√≠dica do documento, n√£o em palavras-chave isoladas
5. **QUINTO**: Considere o nome do arquivo como indicador importante

---

üîç **EXEMPLOS DE VALIDA√á√ÉO CORRETA**:

- Documento chamado "matricula.pdf" que cont√©m hist√≥rico de transmiss√µes ‚Üí CONFIRMAR MATR√çCULA
- Documento chamado "contrato.pdf" que cont√©m cl√°usulas contratuais ‚Üí CONFIRMAR CONTRATO
- Documento chamado "matricula.pdf" mas √© claramente um contrato ‚Üí CORRIGIR PARA CONTRATO
- Documento chamado "contrato.pdf" mas √© claramente uma matr√≠cula ‚Üí CORRIGIR PARA MATR√çCULA

---

‚ö†Ô∏è **AN√ÅLISE ESTRUTURAL AVAN√áADA**:

**Para MATR√çCULA**:
- Cont√©m n√∫mero de matr√≠cula e inscri√ß√£o imobili√°ria
- Cont√©m descri√ß√£o completa do im√≥vel
- Cont√©m hist√≥rico de transmiss√µes (compra e venda, doa√ß√£o, heran√ßa, etc.)
- Cont√©m dados dos propriet√°rios atuais
- Cont√©m √¥nus reais e restri√ß√µes
- **MESMO QUE** mencione contratos registrados ‚Üí √â MATR√çCULA
- **MESMO QUE** mencione certid√µes ‚Üí √â MATR√çCULA
- **MESMO QUE** mencione ITBIs ‚Üí √â MATR√çCULA

**Para CONTRATO**:
- √â PRINCIPALMENTE um instrumento de acordo
- Cont√©m cl√°usulas contratuais
- Cont√©m valores e qualifica√ß√£o das partes
- Cont√©m data e local de assinatura
- **N√ÉO √â** um documento que apenas menciona contratos
- **N√ÉO √â** uma matr√≠cula que menciona contratos registrados

---

üìå ORIENTA√á√ÉO FINAL:

Voc√™ est√° atuando em um ambiente de produ√ß√£o de um cart√≥rio de registro de im√≥veis. Sua classifica√ß√£o ser√° usada para tomada de decis√µes jur√≠dicas com efeitos reais.

**CONFIRME O TIPO IDENTIFICADO PELO NOME DO ARQUIVO, CORRIGINDO APENAS SE NECESS√ÅRIO.**

**IMPORTANTE**: Se o nome do arquivo cont√©m "matricula", o documento √© PROVAVELMENTE uma matr√≠cula, mesmo que mencione outros tipos de documentos.

Sua resposta deve ser:
- Confi√°vel;
- Baseada na ESTRUTURA e FUN√á√ÉO PRINCIPAL do documento;
- Redigida com precis√£o t√©cnica e clareza cartor√°ria.

Responda apenas com o tipo do documento, sem explica√ß√µes.
"""
        
        if not Config.OPENAI_API_KEY:
            raise ValueError("A vari√°vel de ambiente OPENAI_API_KEY n√£o est√° definida!")
        
        client = openai.OpenAI(api_key=Config.OPENAI_API_KEY)
        response = client.chat.completions.create(
            model=model,
            messages=[{"role": "user", "content": prompt_classificacao}],
            temperature=0.0,
            max_tokens=50
        )
        
        content = response.choices[0].message.content
        if content is None:
            return document_type_from_filename
        
        validated_type = content.strip().upper()
        
        # Se a IA confirmou o tipo do nome do arquivo, usar ele
        if validated_type == document_type_from_filename:
            print(f"‚úÖ Tipo confirmado pela IA: {validated_type}")
            return validated_type
        # Se a IA corrigiu o tipo, usar a corre√ß√£o
        else:
            print(f"üîÑ Tipo corrigido pela IA: {document_type_from_filename} ‚Üí {validated_type}")
            return validated_type
        
    except Exception as e:
        print(f"‚ùå Erro na classifica√ß√£o do documento: {str(e)}")
        return "DESCONHECIDO"

def get_checklist_for_document_type(document_type):
    """Retorna o checklist aplic√°vel ao tipo de documento com contexto t√©cnico"""
    
    # Checklist para MATR√çCULA
    checklist_matricula = """
üìã CHECKLIST - MATR√çCULA:

1. O t√≠tulo foi apresentado juntamente com as certid√µes de inteiro teor e de situa√ß√£o jur√≠dica ou de √¥nus reais e de a√ß√µes reipersecut√≥rias (dentro do prazo de validade de 30 dias), comprobat√≥rias do registro anterior?

2. A nova matr√≠cula preenche os requisitos do Art. 176, ¬ß 1¬∫, inciso II, da Lei n.¬∫ 6.015/1973 ‚Äì Lei de Registros P√∫blicos? (REQUISITOS ESSENCIAIS PARA ABERTURA)

3. Verificar dominialidade do im√≥vel. (terrenos foreiros √† Uni√£o ou ao Munic√≠pio, bem como terrenos de Marinha)?

4. Em caso de abertura de matr√≠cula, o im√≥vel for foreiro √† Uni√£o, tem RIP?

5. Incide sobre o im√≥vel algum √¥nus?

6. Para o caso de existir √¥nus, foi apresentado termo de autoriza√ß√£o para o cancelamento de √¥nus ou constou no contrato cl√°usula que autorize esse cancelamento?

7. Constou a qualifica√ß√£o completa dos propriet√°rios?

8. Em matr√≠cula pertencente a esta Serventia, consta a inscri√ß√£o imobili√°ria do im√≥vel/n√∫mero de RIP?

9. A inscri√ß√£o imobili√°ria que consta na matr√≠cula do im√≥vel √© a mesma da certid√£o de ITBI apresentada? (COMPARA√á√ÉO ENTRE DOCUMENTOS)
"""
    
    # Checklist para CONTRATO
    checklist_contrato = """
üìã CHECKLIST - CONTRATO:

1. Todas as vias est√£o iguais?

2. Todas as vias est√£o assinadas/possuem data e local de emiss√£o do contrato?

3. O contrato cont√©m a descri√ß√£o completa do im√≥vel e o n√∫mero da matr√≠cula?

4. A certid√£o de ITBI cont√©m a mesma descri√ß√£o do im√≥vel conforme o contrato e matr√≠cula do im√≥vel? (COMPARA√á√ÉO ENTRE DOCUMENTOS)

5. O valor base para ITBI √© igual ou maior que o valor da transa√ß√£o do im√≥vel? (COMPARA√á√ÉO ENTRE DOCUMENTOS)

6. As partes indicadas no ITBI s√£o as mesmas do contrato? OBS: Observar os nomes e CPF. (COMPARA√á√ÉO ENTRE DOCUMENTOS)

7. O termo de quita√ß√£o ou contrato foram devidamente assinados pelo(a) representante legal do(a) credor fiduci√°rio(a)/interveniente quitante?

8. Os transmitentes est√£o qualificados no t√≠tulo conforme art. 648, V, do CNCGJ/MA?

9. Em caso de apresenta√ß√£o de declara√ß√£o de 1¬™ aquisi√ß√£o, foi assinada pelo(s) comprador(es) com firma devidamente reconhecida?

10. Os transmitentes ou adquirentes s√£o casados sob regime diverso do legal?

11. Se o(s) adquirente (s) e/ou transmitente(s) estiver(em) representado(s) por procurador, constar os dados da representa√ß√£o no texto do registro.

12. Nos casos em que a Pessoa Jur√≠dica for representada por s√≥cio/gerente/administrador ou outro representante legal, deve constar no t√≠tulo os Atos Constitutivos da empresa que justifiquem a representa√ß√£o.

13. Sempre que o transmitente for Pessoa Jur√≠dica verificar se consta CND (Certid√£o Negativa de D√©bitos), ou h√° men√ß√£o sobre a dispensa da referida certid√£o.

14. Foi apresentada a CND do(a) devedor(a) em caso de contrato de m√∫tuo ou CCB?

15. Se tratando de Pessoa Jur√≠dica, imprimir Certid√£o Simplificada ou consulta da empresa na respectiva Junta Comercial.

16. Quando tratar-se de firma individual exigir os documentos de pessoa f√≠sica.

17. Em caso de terreno foreiro √† Uni√£o, foi apresentada a CAT onerosa com a descri√ß√£o correta do im√≥vel e nome e CPF ou CNPJ do outorgante vendedor.

18. Em caso de terreno foreiro ao munic√≠pio, foi apresentado o Termo de Transfer√™ncia de Aforamento ou Escritura P√∫blica de Resgate de Aforamento?

19. O contrato indica a matr√≠cula, descri√ß√£o e inscri√ß√£o imobili√°ria do im√≥vel (verificar se houve atualiza√ß√£o de inscri√ß√£o imobili√°ria)?

20. Existe procura√ß√£o para o(a) representante legal do(a) credor(a) fiduci√°rio(a)?

21. Consta no t√≠tulo requerimento gen√©rico em que as partes autorizem a proceder todos os atos que se fizerem necess√°rios?

22. Deve ser efetuada alguma averba√ß√£o precedente ou subsequente ao registro referente √† qualifica√ß√£o dos propriet√°rios?

23. Em caso de consolida√ß√£o de propriedade de credor fiduci√°rio, foram averbados os leil√µes negativos e a quita√ß√£o da d√≠vida?
"""
    
    # Checklist para ITBI
    checklist_itbi = """
üìã CHECKLIST - ITBI:

1. A certid√£o de ITBI cont√©m a mesma descri√ß√£o do im√≥vel conforme o contrato e matr√≠cula do im√≥vel? (COMPARA√á√ÉO ENTRE DOCUMENTOS)

2. O valor base para ITBI √© igual ou maior que o valor da transa√ß√£o do im√≥vel? (COMPARA√á√ÉO ENTRE DOCUMENTOS)

3. As partes indicadas no ITBI s√£o as mesmas do contrato? (COMPARA√á√ÉO ENTRE DOCUMENTOS)

4. Todos os dados referentes ao ITBI foram conferidos?
"""
    
    # Checklist para CERTID√ÉO
    checklist_certidao = """
üìã CHECKLIST - CERTID√ÉO:

1. A certid√£o est√° dentro do prazo de validade de 30 dias?

2. A certid√£o cont√©m a descri√ß√£o completa do im√≥vel?

3. A certid√£o menciona √¥nus reais ou restri√ß√µes judiciais?

4. A certid√£o identifica corretamente os propriet√°rios atuais?

5. A descri√ß√£o do im√≥vel na certid√£o √© compat√≠vel com outros documentos apresentados? (COMPARA√á√ÉO ENTRE DOCUMENTOS)
"""
    
    # Checklist para PROCURA√á√ÉO
    checklist_procuracao = """
üìã CHECKLIST - PROCURA√á√ÉO:

1. A procura√ß√£o est√° v√°lida e dentro do prazo?

2. A procura√ß√£o indica os poderes espec√≠ficos necess√°rios?

3. A procura√ß√£o foi devidamente reconhecida em firma?

4. O procurador est√° qualificado conforme art. 648, V, do CNCGJ/MA?

5. Os dados do outorgante na procura√ß√£o s√£o compat√≠veis com outros documentos apresentados? (COMPARA√á√ÉO ENTRE DOCUMENTOS)
"""
    
    checklists = {
        'MATR√çCULA': checklist_matricula,
        'CONTRATO': checklist_contrato,
        'ITBI': checklist_itbi,
        'CERTID√ÉO': checklist_certidao,
        'PROCURA√á√ÉO': checklist_procuracao
    }
    
    return checklists.get(document_type, """
üìã CHECKLIST - DOCUMENTO GEN√âRICO:

1. O documento est√° completo e leg√≠vel?

2. O documento cont√©m as informa√ß√µes necess√°rias?

3. O documento est√° dentro do prazo de validade (se aplic√°vel)?

4. O documento foi devidamente assinado e reconhecido (se aplic√°vel)?

5. As informa√ß√µes do documento s√£o compat√≠veis com outros documentos apresentados? (COMPARA√á√ÉO ENTRE DOCUMENTOS)
""")

def extract_document_specific_data(text_content, document_type, filename="", model="gpt-4o"):
    """Extrai TODOS os dados de cada documento, independentemente do tipo"""
    try:
        print(f"üîç Extraindo TODOS os dados de {document_type} - {filename}")
        
        # Prompt unificado para extrair TODOS os dados de qualquer tipo de documento
        prompt = f"""
üìå CONTEXTO:
Voc√™ √© um Registrador Imobili√°rio analisando um documento para qualifica√ß√£o de registro.

Sua tarefa √© extrair **TODOS OS DADOS RELEVANTES** do documento, independentemente do tipo identificado.

---

üìÅ DOCUMENTO ANALISADO:
- Nome do Arquivo: {filename}
- Tipo Identificado: {document_type}
- Conte√∫do: {text_content}

---

üìã DADOS A EXTRAIR (TODOS OS TIPOS DE DOCUMENTO):

**DADOS B√ÅSICOS DO DOCUMENTO:**
- tipo_documento: Tipo do documento (matr√≠cula, contrato, ITBI, certid√£o, procura√ß√£o)
- numero_documento: N√∫mero do documento (matr√≠cula, contrato, ITBI, etc.)
- data_documento: Data do documento
- local_documento: Local de emiss√£o/assinatura

**DADOS DO IM√ìVEL:**
- descricao_imovel: Descri√ß√£o completa do im√≥vel
- inscricao_imobiliaria: Inscri√ß√£o imobili√°ria
- rip: RIP (se houver)
- endereco_completo: Endere√ßo completo do im√≥vel
- area_imovel: √Årea do im√≥vel
- tipo_imovel: Tipo de im√≥vel (terreno, casa, apartamento, etc.)

**DADOS DAS PARTES:**
- proprietarios_atuais: Nome(s) do(s) propriet√°rio(s) atual(is)
- compradores: Nome(s) do(s) comprador(es) (se aplic√°vel)
- vendedores: Nome(s) do(s) vendedor(es) (se aplic√°vel)
- transmitentes: Nome(s) do(s) transmitente(s) (se aplic√°vel)
- adquirentes: Nome(s) do(s) adquirente(s) (se aplic√°vel)
- outorgantes: Nome(s) do(s) outorgante(s) (se aplic√°vel)
- outorgados: Nome(s) do(s) outorgado(s) (se aplic√°vel)

**DADOS PESSOAIS:**
- cpfs_cnpjs: CPFs/CNPJs das partes envolvidas
- rgs: RGs das partes envolvidas
- enderecos_partes: Endere√ßos das partes envolvidas
- estados_civis: Estados civis das partes
- profissoes: Profiss√µes das partes
- nacionalidades: Nacionalidades das partes

**DADOS FINANCEIROS:**
- valor_transacao: Valor da transa√ß√£o
- valor_contrato: Valor do contrato
- valor_itbi: Valor do ITBI
- forma_pagamento: Forma de pagamento
- valor_avaliacao: Valor de avalia√ß√£o

**√îNUS E RESTRI√á√ïES:**
- onus_ativos: Lista de √¥nus ativos
- restricoes_judiciais: Restri√ß√µes judiciais
- hipotecas: Hipotecas mencionadas
- penhoras: Penhoras mencionadas
- usufrutos: Usufrutos mencionados

**CERTID√ïES E DOCUMENTOS:**
- certidoes_presentes: Lista de certid√µes mencionadas
- prazos_certidoes: Prazos de validade das certid√µes
- documentos_anexos: Documentos anexos mencionados
- procuracoes: Procura√ß√µes mencionadas

**HIST√ìRICO E TRANSMISS√ïES:**
- historico_transmissoes: Hist√≥rico de transmiss√µes
- data_ultima_transmissao: Data da √∫ltima transmiss√£o
- valor_ultima_transmissao: Valor da √∫ltima transmiss√£o

**CL√ÅUSULAS E CONDI√á√ïES:**
- clausulas_especiais: Cl√°usulas especiais do contrato
- condicoes_especiais: Condi√ß√µes especiais
- garantias: Garantias oferecidas

**DOMINIALIDADE:**
- tipo_dominialidade: Tipo de dominialidade
- senhorio_direto: Senhorio direto (se foreira)
- enfiteuta: Enfiteuta (se foreira)

**DADOS FISCAIS (ITBI):**
- numero_itbi: N√∫mero do ITBI
- aliquota_aplicada: Al√≠quota aplicada
- base_calculo: Base de c√°lculo
- valor_imposto: Valor do imposto
- isencao_aplicada: Isen√ß√£o aplicada

**DADOS DE REPRESENTA√á√ÉO:**
- representante_legal: Representante legal
- poderes_especificos: Poderes espec√≠ficos (procura√ß√£o)
- data_procuracao: Data da procura√ß√£o
- validade_procuracao: Validade da procura√ß√£o

**OBSERVA√á√ïES E PROBLEMAS:**
- observacoes: Observa√ß√µes importantes
- problemas_identificados: Problemas identificados
- inconsistencias: Inconsist√™ncias encontradas

üß∑ **FORMATO OBRIGAT√ìRIO DA RESPOSTA (JSON V√ÅLIDO)**:
{{
    "tipo_documento": "{document_type}",
    "numero_documento": "123456",
    "data_documento": "15/12/2020",
    "local_documento": "S√£o Lu√≠s/MA",
    "descricao_imovel": "Casa residencial localizada na Rua X...",
    "inscricao_imobiliaria": "II-123456",
    "rip": "RIP-123456",
    "endereco_completo": "Rua A, 123, Centro, S√£o Lu√≠s/MA",
    "area_imovel": "150m¬≤",
    "tipo_imovel": "Casa residencial",
    "proprietarios_atuais": "Jo√£o da Silva, Maria da Silva",
    "compradores": "Jo√£o da Silva",
    "vendedores": "Maria da Silva",
    "transmitentes": "Maria da Silva",
    "adquirentes": "Jo√£o da Silva",
    "outorgantes": "",
    "outorgados": "",
    "cpfs_cnpjs": "123.456.789-00, 987.654.321-00",
    "rgs": "1234567 SSP/MA, 7654321 SSP/MA",
    "enderecos_partes": "Rua A, 123, Centro, S√£o Lu√≠s/MA",
    "estados_civis": "Casado, Casada",
    "profissoes": "Advogado, M√©dica",
    "nacionalidades": "Brasileira, Brasileira",
    "valor_transacao": "R$ 150.000,00",
    "valor_contrato": "R$ 150.000,00",
    "valor_itbi": "R$ 3.000,00",
    "forma_pagamento": "√Ä vista",
    "valor_avaliacao": "R$ 150.000,00",
    "onus_ativos": ["Hipoteca em favor do Banco X"],
    "restricoes_judiciais": [],
    "hipotecas": ["Hipoteca em favor do Banco X"],
    "penhoras": [],
    "usufrutos": [],
    "certidoes_presentes": ["Certid√£o de inteiro teor", "Certid√£o de situa√ß√£o jur√≠dica"],
    "prazos_certidoes": ["30 dias", "30 dias"],
    "documentos_anexos": ["Certid√£o de casamento", "Certid√£o de √≥bito"],
    "procuracoes": [],
    "historico_transmissoes": ["Compra e venda em 2020", "Doa√ß√£o em 2015"],
    "data_ultima_transmissao": "15/12/2020",
    "valor_ultima_transmissao": "R$ 150.000,00",
    "clausulas_especiais": ["Cl√°usula de arras", "Cl√°usula de garantia"],
    "condicoes_especiais": "Entrega em 30 dias",
    "garantias": "Garantia de evic√ß√£o",
    "tipo_dominialidade": "Propriedade plena",
    "senhorio_direto": "",
    "enfiteuta": "",
    "numero_itbi": "ITBI-123456",
    "aliquota_aplicada": "2%",
    "base_calculo": "R$ 150.000,00",
    "valor_imposto": "R$ 3.000,00",
    "isencao_aplicada": "",
    "representante_legal": "",
    "poderes_especificos": "",
    "data_procuracao": "",
    "validade_procuracao": "",
    "observacoes": "Documento em bom estado",
    "problemas_identificados": [],
    "inconsistencias": []
}}

‚ö†Ô∏è **IMPORTANTE**: 
- Extraia **TODOS OS DADOS RELEVANTES** do documento
- **N√ÉO IGNORE** nenhuma informa√ß√£o importante
- **CONSIDERE** todas as men√ß√µes a outros documentos, valores, datas, etc.
- Se um dado n√£o estiver presente, use string vazia ("")
- Responda APENAS em JSON v√°lido

**EXEMPLOS DO QUE EXTRAIR:**
- N√∫meros de documentos ‚Üí EXTRAIR
- Nomes de pessoas ‚Üí EXTRAIR
- Valores ‚Üí EXTRAIR
- Datas ‚Üí EXTRAIR
- Endere√ßos ‚Üí EXTRAIR
- √înus ‚Üí EXTRAIR
- Certid√µes ‚Üí EXTRAIR
- Cl√°usulas ‚Üí EXTRAIR
- Observa√ß√µes ‚Üí EXTRAIR

**RESPONDA APENAS O JSON, SEM TEXTO ADICIONAL.**
"""
        

        
        if not Config.OPENAI_API_KEY:
            raise ValueError("A vari√°vel de ambiente OPENAI_API_KEY n√£o est√° definida!")
        
        client = openai.OpenAI(api_key=Config.OPENAI_API_KEY)
        response = client.chat.completions.create(
            model=model,
            messages=[{"role": "user", "content": prompt}],
            temperature=0.0,
            max_tokens=2000
        )
        
        content = response.choices[0].message.content
        
        if not content:
            print("‚ùå Resposta vazia da OpenAI")
            return {"error": "Resposta vazia da OpenAI"}
        
        # Limpar e processar JSON com tratamento de erro melhorado
        def clean_json_response(response_text):
            # Remover blocos markdown
            response_text = re.sub(r'^```json\s*|```$', '', response_text.strip(), flags=re.MULTILINE)
            response_text = re.sub(r'^```\s*|```$', '', response_text.strip(), flags=re.MULTILINE)
            
            # Tentar encontrar JSON v√°lido
            match = re.search(r'\{[\s\S]+\}', response_text)
            if match:
                return match.group(0)
            return response_text.strip()

        try:
            cleaned_content = clean_json_response(content)
            print(f"üîç Conte√∫do limpo (primeiros 500 chars): {cleaned_content[:500]}")
            
            # Tentar parsear JSON
            try:
                result = json.loads(cleaned_content)
                print(f"‚úÖ JSON parseado com sucesso para {document_type}")
                return result
            except json.JSONDecodeError as json_error:
                print(f"‚ùå Erro no parse JSON: {json_error}")
                print(f"üîç Tentando corrigir JSON...")
                
                # Tentar corrigir problemas comuns
                fixed_content = cleaned_content
                
                # Corrigir v√≠rgulas finais
                fixed_content = re.sub(r',\s*}', '}', fixed_content)
                fixed_content = re.sub(r',\s*]', ']', fixed_content)
                
                # Corrigir aspas n√£o fechadas
                fixed_content = re.sub(r'"([^"]*)$', r'"\1"', fixed_content)
                
                # Tentar parsear novamente
                try:
                    result = json.loads(fixed_content)
                    print(f"‚úÖ JSON corrigido e parseado com sucesso")
                    return result
                except json.JSONDecodeError as json_error2:
                    print(f"‚ùå Erro persistente no JSON: {json_error2}")
                    print(f"üîç Conte√∫do problem√°tico: {fixed_content}")
                    
                    # Retornar estrutura b√°sica em caso de erro
                    return {
                        "error": "Erro no processamento da resposta da IA",
                        "raw_content": content[:200],
                        "json_error": str(json_error2)
                    }
                    
        except Exception as parse_error:
            print(f"‚ùå Erro geral no processamento: {parse_error}")
            return {"error": f"Erro no processamento: {str(parse_error)}"}
        
    except Exception as e:
        print(f"‚ùå Erro na extra√ß√£o de dados do documento: {str(e)}")
        return {"error": f"Erro na extra√ß√£o: {str(e)}"}

def analyze_checklist_with_document_data(all_results, model="gpt-4o"):
    """Analisa o checklist com base em TODOS os dados extra√≠dos de TODOS os documentos"""
    try:
        print(f"üîç Analisando checklist com TODOS os dados de {len(all_results)} documentos")
        
        # Preparar contexto completo com TODOS os dados de TODOS os documentos
        documents_context = ""
        document_summary = []
        all_document_data = {}
        
        for result in all_results:
            doc_data = result.get('document_data', {})
            if not doc_data.get('error'):
                # Resumo do documento
                doc_summary = f"Documento: {result['filename']} ({result['document_type']})"
                document_summary.append(doc_summary)
                
                # Armazenar todos os dados do documento
                all_document_data[result['filename']] = {
                    'type': result['document_type'],
                    'data': doc_data
                }
                
                # Dados detalhados do documento
                documents_context += f"\n--- DOCUMENTO: {result['filename']} ({result['document_type']}) ---\n"
                for key, value in doc_data.items():
                    if value and str(value).strip():
                        documents_context += f"{key}: {value}\n"
        
        # Obter checklist completo
        checklist = get_checklist_for_document_type("GENERAL")
        
        # Criar resumo dos documentos dispon√≠veis
        documents_available = "\n".join(document_summary)
        
        prompt = f"""
üìå CONTEXTO:
Voc√™ √© um Registrador Imobili√°rio analisando documentos para qualifica√ß√£o de registro.

Sua tarefa √© responder **CADA PERGUNTA ESPEC√çFICA** do checklist com base nos dados extra√≠dos dos documentos.

---

üìÅ DOCUMENTOS DISPON√çVEIS PARA AN√ÅLISE:
{documents_available}

üìã DADOS COMPLETOS DE TODOS OS DOCUMENTOS:
{documents_context}

---

üìã CHECKLIST DE QUALIFICA√á√ÉO:

‚ö†Ô∏è **INSTRU√á√ïES CR√çTICAS**:
1. **ANALISE CADA PERGUNTA INDIVIDUALMENTE**: Cada pergunta tem um contexto espec√≠fico
2. **BUSQUE DADOS RELEVANTES**: Procure nos documentos dados que respondam √† pergunta espec√≠fica
3. **RELACIONE CORRETAMENTE**: Conecte a pergunta com os dados corretos dos documentos
4. **JUSTIFIQUE PRECISAMENTE**: Baseie a resposta nos dados encontrados

**EXEMPLOS DE AN√ÅLISE CORRETA**:

**Pergunta 1**: "O t√≠tulo foi apresentado juntamente com as certid√µes de inteiro teor e de situa√ß√£o jur√≠dica?"
- ‚úÖ **Buscar nos dados**: certidoes_presentes, prazos_certidoes, tipo_documento
- ‚úÖ **Resposta correta**: "SIM - Documento cont√©m certid√£o de situa√ß√£o jur√≠dica v√°lida por 30 dias. [Doc: certidao.pdf]"

**Pergunta 2**: "A nova matr√≠cula preenche os requisitos do Art. 176?"
- ‚úÖ **Buscar nos dados**: numero_matricula, inscricao_imobiliaria, proprietarios_atuais, descricao_imovel
- ‚úÖ **Resposta correta**: "SIM - Matr√≠cula cont√©m n√∫mero, inscri√ß√£o imobili√°ria e descri√ß√£o completa do im√≥vel. [Doc: matricula.pdf]"

**Pergunta 3**: "Verificar dominialidade do im√≥vel?"
- ‚úÖ **Buscar nos dados**: tipo_dominialidade, senhorio_direto, enfiteuta
- ‚úÖ **Resposta correta**: "N√ÉO - N√£o h√° men√ß√£o a terreno foreiro nos documentos. [Doc: matricula.pdf]"

Para cada item do checklist:
- **ANALISE A PERGUNTA ESPEC√çFICA**
- **BUSQUE DADOS RELEVANTES** nos documentos
- **RESPONDA**: `SIM`, `N√ÉO` ou `N.A.`
- **JUSTIFIQUE** com dados espec√≠ficos encontrados
- **INDIQUE** quais documentos foram utilizados

üß∑ **FORMATO OBRIGAT√ìRIO DA RESPOSTA (JSON V√ÅLIDO)**:
{{
    "item1": {{
        "resposta": "SIM",
        "justificativa": "Certid√£o de situa√ß√£o jur√≠dica presente com prazo de validade de 30 dias. [Documentos utilizados: certidao.pdf]"
    }},
    "item2": {{
        "resposta": "SIM", 
        "justificativa": "Matr√≠cula cont√©m n√∫mero, inscri√ß√£o imobili√°ria e descri√ß√£o completa do im√≥vel conforme Art. 176. [Documentos utilizados: matricula.pdf]"
    }},
    "item3": {{
        "resposta": "N√ÉO",
        "justificativa": "N√£o h√° men√ß√£o a terreno foreiro √† Uni√£o ou Munic√≠pio nos documentos analisados. [Documentos utilizados: matricula.pdf]"
    }}
}}

CHECKLIST A SER RESPONDIDO:
{checklist}

‚ö†Ô∏è **IMPORTANTE**: 
- **ANALISE CADA PERGUNTA ESPECIFICAMENTE**
- **BUSQUE DADOS RELEVANTES** para cada pergunta
- **N√ÉO D√ä RESPOSTAS GEN√âRICAS**
- **BASEIE-SE NOS DADOS ENCONTRADOS**
- **JUSTIFIQUE COM DADOS ESPEC√çFICOS**
- Se n√£o houver dados suficientes, marque como `N.A.`
- Sempre indique quais documentos foram utilizados
- Responda APENAS em JSON v√°lido

**DADOS IMPORTANTES PARA BUSCAR**:
- **Certid√µes**: certidoes_presentes, prazos_certidoes, tipo_certidao
- **Matr√≠cula**: numero_matricula, inscricao_imobiliaria, proprietarios_atuais, descricao_imovel
- **Dominialidade**: tipo_dominialidade, senhorio_direto, enfiteuta, rip
- **√înus**: onus_ativos, restricoes_judiciais, hipotecas, penhoras
- **Valores**: valor_transacao, valor_contrato, valor_itbi, valor_avaliacao
- **Partes**: compradores, vendedores, transmitentes, adquirentes, cpfs_cnpjs
- **Datas**: data_documento, data_ultima_transmissao, data_contrato
- **Assinaturas**: representante_legal, poderes_especificos, rgs, enderecos_partes
- **Qualifica√ß√£o**: estados_civis, profissoes, nacionalidades
- **Documentos**: documentos_anexos, procuracoes, clausulas_especiais

**RESPONDA APENAS O JSON, SEM TEXTO ADICIONAL.**
"""
        
        if not Config.OPENAI_API_KEY:
            raise ValueError("A vari√°vel de ambiente OPENAI_API_KEY n√£o est√° definida!")
        
        client = openai.OpenAI(api_key=Config.OPENAI_API_KEY)
        response = client.chat.completions.create(
            model=model,
            messages=[{"role": "user", "content": prompt}],
            temperature=0.0,
            max_tokens=4000
        )
        
        content = response.choices[0].message.content
        
        if not content:
            print("‚ùå Resposta vazia da OpenAI")
            return {"error": "Resposta vazia da OpenAI"}
        
        # Limpar e processar JSON
        def clean_json_response(response_text):
            response_text = re.sub(r'^```json\s*|```$', '', response_text.strip(), flags=re.MULTILINE)
            response_text = re.sub(r'^```\s*|```$', '', response_text.strip(), flags=re.MULTILINE)
            match = re.search(r'\{[\s\S]+\}', response_text)
            if match:
                return match.group(0)
            return response_text.strip()

        try:
            cleaned_content = clean_json_response(content)
            result = json.loads(cleaned_content)
            print(f"‚úÖ An√°lise do checklist conclu√≠da")
            return result
            
        except Exception as e:
            print(f"‚ùå Erro no processamento do checklist: {str(e)}")
            return {"error": f"Erro no processamento do checklist: {str(e)}"}
        
    except Exception as e:
        print(f"‚ùå Erro na an√°lise do checklist: {str(e)}")
        return {"error": f"Erro na an√°lise do checklist: {str(e)}"}

def analyze_document_with_checklist(text_content, document_type, filename="", model="gpt-4o", all_documents=None, all_filenames=None):
    """Fun√ß√£o mantida para compatibilidade - agora usa a nova l√≥gica"""
    return extract_document_specific_data(text_content, document_type, filename, model)

# def analyze_qualification_documents(documents_texts, filenames=None, model="gpt-4o"):
    """Analisa m√∫ltiplos documentos para qualifica√ß√£o - cada documento individualmente"""
    try:
        print(f"üîç Iniciando an√°lise de qualifica√ß√£o com {model}")
        
        if filenames is None:
            filenames = [f"documento_{i+1}.pdf" for i in range(len(documents_texts))]
        
        all_results = []
        
        # Primeira etapa: Analisar cada documento individualmente
        for i, (doc_text, filename) in enumerate(zip(documents_texts, filenames)):
            print(f"üìÑ Analisando documento {i+1}/{len(documents_texts)}: {filename}")
            
            # Etapa 1: Classificar tipo do documento
            document_type = classify_document_type(doc_text, filename, model)
            print(f"‚úÖ Documento {i+1} classificado como: {document_type}")
            
            # Etapa 2: Extrair dados espec√≠ficos do documento
            document_data = extract_document_specific_data(doc_text, document_type, filename, model)
            
            all_results.append({
                'document_index': i+1,
                'filename': filename,
                'document_type': document_type,
                'document_data': document_data
            })
        
        # Segunda etapa: Analisar checklist com base nos dados extra√≠dos
        checklist_analysis = analyze_checklist_with_document_data(all_results, model)
        
        # Consolidar resultados
        consolidated_result = {
            'total_documents': len(documents_texts),
            'documents_analyzed': all_results,
            'checklist_analysis': checklist_analysis,
            'summary': {
                'matriculas': len([r for r in all_results if r['document_type'] == 'MATR√çCULA']),
                'contratos': len([r for r in all_results if r['document_type'] == 'CONTRATO']),
                'itbis': len([r for r in all_results if r['document_type'] == 'ITBI']),
                'certidoes': len([r for r in all_results if r['document_type'] == 'CERTID√ÉO']),
                'procuracoes': len([r for r in all_results if r['document_type'] == 'PROCURA√á√ÉO']),
                'desconhecidos': len([r for r in all_results if r['document_type'] == 'DESCONHECIDO'])
            }
        }
        
        print(f"‚úÖ An√°lise de qualifica√ß√£o conclu√≠da: {len(documents_texts)} documentos processados")
        return consolidated_result
        
    except Exception as e:
        print(f"‚ùå Erro na an√°lise de qualifica√ß√£o: {str(e)}")
        return {"error": f"Erro na an√°lise de qualifica√ß√£o: {str(e)}"}

def clean_and_validate_fields(fields_dict, service_type='certidao'):
    """Limpa e valida os campos extra√≠dos pela OpenAI"""
    if service_type == 'certidao':
        expected_fields = [
            'cnm',
            'descricao_imovel',
            'proprietarios',
            'senhorio_enfiteuta',
            'inscricao_imobiliaria',
            'rip',
            'onus_certidao_negativa',
            'nome_solicitante'
        ]
    else:
        expected_fields = []
    
    cleaned_fields = {}
    
    for field in expected_fields:
        value = fields_dict.get(field, '')
        
        # Converter para string e limpar
        if value is None:
            value = ''
        elif isinstance(value, (dict, list)):
            # Se for objeto ou lista, converter para string
            value = str(value)
        else:
            value = str(value).strip()
        
        cleaned_fields[field] = value
    
    print(f"üßπ Campos limpos: {len(cleaned_fields)} campos processados")
    
    # Mostrar dados extra√≠dos no terminal
    print("\n" + "="*60)
    print(f"üìã DADOS EXTRA√çDOS PELA IA ({service_type.upper()}):")
    print("="*60)
    for field, value in cleaned_fields.items():
        if value and value.strip():
            print(f"‚úÖ {field}: {value}")
        else:
            print(f"‚ùå {field}: (vazio)")
    print("="*60)
    
    return cleaned_fields

def extract_fields_with_openai(text, model="gpt-4o", service_type="certidao"):
    """Envia o texto para a OpenAI API e retorna os campos extra√≠dos em JSON"""
    try:
        print(f"üîç Iniciando extra√ß√£o com OpenAI - Modelo: {model} - Servi√ßo: {service_type}")
        print(f"üìù Tamanho do texto: {len(text)} caracteres")
        print(f"üéØ Modelo que ser√° usado na API OpenAI: {model}")
        
        if service_type == "certidao":
            prompt = (
                "Extraia os seguintes campos do texto de uma matr√≠cula imobili√°ria abaixo. "
                "Responda APENAS em JSON v√°lido, sem explica√ß√µes ou texto adicional. "
                "Todos os valores devem ser strings. Se um campo n√£o for encontrado, use string vazia (\"\").\n\n"
                "Campos a extrair:\n"
                "- cnm: Cadastro Nacional de Matr√≠cula (n√∫mero da matr√≠cula)\n"
                "- descricao_imovel: Descri√ß√£o completa do im√≥vel (endere√ßo, √°rea, confronta√ß√µes, benfeitorias)\n"
                "- proprietarios: Nome(s) completo(s) do(s) propriet√°rio(s) atual(is), com todos os dados dispon√≠veis: CPF, RG, nacionalidade, estado civil, regime de bens e endere√ßo. **IMPORTANTE:** Se o propriet√°rio for casado, INCLUA O C√îNJUGE com todos os dados (nome, CPF, RG, nacionalidade, estado civil, regime de bens, endere√ßo). Analise toda a sequ√™ncia da matr√≠cula, considerando transmiss√µes (compra e venda, doa√ß√£o, heran√ßa, etc.) para identificar corretamente quem √© o PROPRIET√ÅRIO ATUAL do im√≥vel, mesmo que haja v√°rios registros anteriores. Se houver mais de um propriet√°rio (copropriet√°rios), liste TODOS com seus respectivos dados. ex: Para casais, use formato: 'Jo√£o da Silva, CPF: 123.456.789-00, casado, regime de comunh√£o parcial, residente em... E Maria da Silva, CPF: 987.654.321-00, casada, regime de comunh√£o parcial, residente em..."
                "- senhorio_enfiteuta: Nome do senhorio direto e enfiteuta (se aplic√°vel)\n"
                "- inscricao_imobiliaria: Inscri√ß√£o imobili√°ria (n√∫mero de inscri√ß√£o no cart√≥rio)\n"
                "- rip: RIP (Registro de Im√≥veis P√∫blicos) se houver\n"
                "- onus_certidao_negativa: √înus reais, restri√ß√µes judiciais e administrativas, ou certid√£o negativa (transcreva o texto completo referente a esses itens). Tipos de √îNUS: Hipoteca, Aliena√ß√£o, Promessa de Compra e Venda, Penhora, Indisponibilidade, Usufruto, Cl√°sula Restritiva, Averba√ß√£o Premonit√≥ria, Bloqueio, Arresto, Execu√ß√£o, C√©dula de Cr√©dito Comercial, C√©dula de Cr√©dito Imobili√°rio E OUTROS. **IMPORTANTE:** N√ÉO inclua √¥nus, restri√ß√µes ou gravames que j√° tenham sido cancelados, extintos ou baixados no documento. Considere apenas √¥nus ATIVOS. Se houver men√ß√£o de cancelamento, desconsidere esse √¥nus.\n"
                "- nome_solicitante: Nome completo do solicitante da certid√£o\n\n"
                "**EXEMPLOS DE FORMATA√á√ÉO CORRETA**:\n"
                "1. Propriet√°rio solteiro: 'Jo√£o da Silva, CPF: 123.456.789-00, solteiro, brasileiro, residente em...'\n"
                "2. Casal: 'Jo√£o da Silva, CPF: 123.456.789-00, casado, regime de comunh√£o parcial, residente em... E Maria da Silva, CPF: 987.654.321-00, casada, regime de comunh√£o parcial, residente em...'\n"
                "3. M√∫ltiplos propriet√°rios: 'Jo√£o da Silva, CPF: 123.456.789-00, casado, residente em... E Maria da Silva, CPF: 987.654.321-00, casada, residente em... E Pedro Santos, CPF: 111.222.333-00, solteiro, residente em...'\n\n"
                "Exemplo de formato esperado:\n"
                "{\"cnm\": \"123456\", \"descricao_imovel\": \"Casa residencial localizada na Rua X...\", "
                "\"proprietarios\": \"Jo√£o da Silva, CPF: 123.456.789-00, casado, regime de comunh√£o parcial, residente em... E Maria da Silva, CPF: 987.654.321-00, casada, regime de comunh√£o parcial, residente em...\", "
                "... }\n\n"
                "Texto da matr√≠cula:\n" + text
            )
        else:
            return {"error": f"Tipo de servi√ßo n√£o suportado: {service_type}"}
        
        # Verificar se a chave da API est√° configurada
        if not Config.OPENAI_API_KEY:
            raise ValueError("A vari√°vel de ambiente OPENAI_API_KEY n√£o est√° definida!")
        
        # Fazer a chamada para a API OpenAI
        print("üì° Enviando requisi√ß√£o para OpenAI...")
        client = openai.OpenAI(api_key=Config.OPENAI_API_KEY)
        response = client.chat.completions.create(
            model=model,
            messages=[{"role": "user", "content": prompt}],
            temperature=0.0,
            max_tokens=4000
        )
        
        content = response.choices[0].message.content
        print(f"‚úÖ Resposta recebida da OpenAI - Tamanho: {len(content) if content else 0}")
        
        if content is None:
            return {"error": "Resposta vazia da OpenAI"}
        
        # Processar resposta JSON
        try:
            # Limpar a resposta de poss√≠veis blocos markdown
            cleaned_content = re.sub(r'^```json\s*|```$', '', content.strip(), flags=re.MULTILINE)
            cleaned_content = re.sub(r'^```\s*|```$', '', cleaned_content.strip(), flags=re.MULTILINE)
            
            # Tentar encontrar JSON v√°lido na resposta
            match = re.search(r'\{[\s\S]+\}', cleaned_content)
            if match:
                result = json.loads(match.group(0))
            else:
                result = json.loads(cleaned_content)
            
            print("‚úÖ Campos extra√≠dos com sucesso")
            print(f"üìä Campos encontrados: {list(result.keys())}")
            
            return result
            
        except Exception as e:
            print(f"‚ùå Erro ao processar JSON da resposta: {str(e)}")
            return {"error": f"Erro ao interpretar resposta: {str(e)}", "raw": content}
            
    except Exception as e:
        print(f"‚ùå Erro geral na extra√ß√£o OpenAI: {str(e)}")
        return {"error": f"Erro na comunica√ß√£o com OpenAI: {str(e)}", "raw": None}


def extract_relevant_sections(document_text, doc_type):
    """Extrai apenas se√ß√µes relevantes do documento para economizar tokens"""
    if not document_text or not doc_type:
        return document_text
    
    # Mapear palavras-chave por tipo de documento
    keywords_by_type = {
        'contrato': ['contrato', 'compra', 'venda', 'comprador', 'vendedor', 'pre√ßo', 'valor', 'pagamento'],
        'matricula': ['matr√≠cula', 'registro', 'im√≥vel', 'propriet√°rio', '√°rea', 'confronta√ß√µes'],
        'certidao': ['certid√£o', 'd√©bitos', '√¥nus', 'gravames', 'hipoteca', 'penhora'],
        'procuracao': ['procura√ß√£o', 'outorgante', 'outorgado', 'poderes', 'representa√ß√£o'],
        'rg': ['identidade', 'rg', 'nome', 'filia√ß√£o', 'nascimento'],
        'cpf': ['cpf', 'receita federal', 'situa√ß√£o cadastral'],
        'comprovante_residencia': ['endere√ßo', 'resid√™ncia', 'domic√≠lio', 'correspond√™ncia'],
        'estado_civil': ['estado civil', 'casamento', 'solteiro', 'casado', 'divorciado', 'vi√∫vo'],
        'itbi': ['itbi', 'imposto', 'transmiss√£o', 'bens im√≥veis'],
        'iptu': ['iptu', 'predial', 'territorial', 'urbano']
    }
    
    # Obter palavras-chave para o tipo de documento
    keywords = keywords_by_type.get(doc_type, [])
    
    if not keywords:
        return document_text  # Se n√£o h√° palavras-chave espec√≠ficas, retorna o texto completo
    
    # Dividir o texto em par√°grafos
    paragraphs = document_text.split('\n')
    relevant_paragraphs = []
    
    for paragraph in paragraphs:
        paragraph_lower = paragraph.lower()
        # Verificar se o par√°grafo cont√©m alguma palavra-chave relevante
        if any(keyword in paragraph_lower for keyword in keywords):
            relevant_paragraphs.append(paragraph)
    
    # Se encontrou par√°grafos relevantes, retorna apenas eles
    if relevant_paragraphs:
        return '\n'.join(relevant_paragraphs)
    
    # Se n√£o encontrou nada relevante, retorna o texto completo (fallback)
    return document_text


# def analyze_qualification_documents(documents, filenames, model="gpt-4o"):
    """An√°lise avan√ßada de qualifica√ß√£o usando OpenAI com verifica√ß√£o rigorosa de documentos"""
    try:
        print(f"üîç Iniciando an√°lise de qualifica√ß√£o avan√ßada com {len(documents)} documentos")
        print(f"üìÅ Arquivos: {filenames}")
        
        # Classificar documentos por tipo baseado no nome do arquivo
        document_types = classify_documents_by_filename(filenames)
        
        # Criar prompt espec√≠fico para an√°lise de qualifica√ß√£o
        prompt = create_qualification_analysis_prompt(documents, document_types, filenames)
        
        if not Config.OPENAI_API_KEY:
            raise ValueError("A vari√°vel de ambiente OPENAI_API_KEY n√£o est√° definida!")
        
        print("üì° Enviando requisi√ß√£o para OpenAI (An√°lise de Qualifica√ß√£o)...")
        client = openai.OpenAI(api_key=Config.OPENAI_API_KEY)
        response = client.chat.completions.create(
            model=model,
            messages=[{"role": "user", "content": prompt}],
            temperature=0.0,
            max_tokens=4000
        )
        
        content = response.choices[0].message.content
        print(f"‚úÖ Resposta recebida da OpenAI - Tamanho: {len(content) if content else 0}")
        
        if content is None:
            return {"error": "Resposta vazia da OpenAI"}
        
        # Processar resposta JSON
        try:
            cleaned_content = re.sub(r'^```json\s*|```$', '', content.strip(), flags=re.MULTILINE)
            cleaned_content = re.sub(r'^```\s*|```$', '', cleaned_content.strip(), flags=re.MULTILINE)
            
            match = re.search(r'\{[\s\S]+\}', cleaned_content)
            if match:
                result = json.loads(match.group(0))
            else:
                result = json.loads(cleaned_content)
            
            print("‚úÖ An√°lise de qualifica√ß√£o processada com sucesso")
            print(f"üìä Itens analisados: {len([k for k in result.keys() if k.startswith('item')])}")
            
            # Adicionar metadados da an√°lise
            result['documents_analyzed'] = [
                {'filename': fname, 'type': doc_type} 
                for fname, doc_type in zip(filenames, document_types)
            ]
            result['analysis_method'] = 'advanced_qualification'
            result['total_documents'] = len(documents)
            
            return result
            
        except Exception as e:
            print(f"‚ùå Erro ao processar JSON da qualifica√ß√£o: {str(e)}")
            return {"error": f"Erro ao interpretar resposta: {str(e)}", "raw": content}
            
    except Exception as e:
        print(f"‚ùå Erro na an√°lise de qualifica√ß√£o: {str(e)}")
        return {"error": f"Erro na an√°lise: {str(e)}"}


def classify_documents_by_filename(filenames):
    """Classifica documentos por tipo baseado no nome real do arquivo (sugest√£o do usu√°rio)"""
    document_types = []
    
    # Mapeamento direto baseado no nome do arquivo (mais confi√°vel)
    type_mapping = {
        # Documentos principais
        'contrato': ['contrato', 'compra', 'venda', 'escritura'],
        'matricula': ['matricula', 'matr√≠cula', '3ri', 'registro', 'imovel', 'im√≥vel'],
        
        # Certid√µes espec√≠ficas
        'certidao_inteiro_teor': ['inteiro_teor', 'inteiro', 'teor', 'certidao_inteiro'],
        'certidao_situacao_juridica': ['situacao_juridica', 'situa√ß√£o_jur√≠dica', 'situacao', 'juridica'],
        'certidao_onus_reais': ['onus_reais', '√¥nus_reais', 'onus', '√¥nus'],
        'certidao_acoes_reipersecutorias': ['acoes_reipersecutorias', 'a√ß√µes_reipersecutoria', 'acoes', 'a√ß√µes', 'reipersecutoria'],
        'certidao_itbi': ['itbi', 'certidao_itbi'],
        'certidao_rip': ['rip', 'certidao_rip'],
        'certidao_junta_comercial': ['junta_comercial', 'junta', 'comercial'],
        
        # Documentos de apoio
        'procuracao': ['procuracao', 'procura√ß√£o'],
        'cnd': ['cnd', 'negativa', 'debitos', 'd√©bitos'],
        'termo_quitacao': ['quitacao', 'quita√ß√£o', 'termo_quitacao'],
        'termo_autorizacao': ['autorizacao', 'autoriza√ß√£o', 'termo_autorizacao'],
        'atos_constitutivos': ['atos_constitutivos', 'social', 'ata', 'constitutivo'],
        'declaracao_primeira_aquisicao': ['declaracao', 'declara√ß√£o', 'primeira_aquisicao', 'aquisicao', 'aquisi√ß√£o'],
        'pacto_antenupcial': ['pacto_antenupcial', 'pacto', 'antenupcial'],
        
        # Documentos especiais
        'cat_spu': ['cat_spu', 'spu', 'cat'],
        'termo_aforamento': ['aforamento', 'termo_aforamento'],
        'boletim_cadastro_imobiliario': ['boletim', 'cadastro', 'imobiliario', 'imobili√°rio'],
        'leilao': ['leilao', 'leil√£o'],
        'escritura': ['escritura'],
        'documento_identidade': ['rg', 'cpf', 'identidade', 'documento']
    }
    
    for filename in filenames:
        filename_lower = filename.lower().replace('_', ' ').replace('-', ' ')
        doc_type = 'documento_generico'  # Padr√£o
        
        # Procurar correspond√™ncia mais espec√≠fica primeiro
        for type_name, keywords in type_mapping.items():
            if any(keyword in filename_lower for keyword in keywords):
                doc_type = type_name
                break
        
        document_types.append(doc_type)
        print(f"üìù Arquivo '{filename}' classificado como: {doc_type}")
    
    return document_types


def create_qualification_analysis_prompt(documents, document_types, filenames):
    """Cria prompt espec√≠fico para an√°lise de qualifica√ß√£o com mapeamento de arquivos"""
    
    prompt = """
Voc√™ √© um especialista em an√°lise de documentos imobili√°rios para qualifica√ß√£o registral.
Analise os documentos fornecidos e responda ao checklist de qualifica√ß√£o, considerando que cada item deve ser analisado com base nos arquivos espec√≠ficos relacionados.

RESPONDA APENAS EM JSON V√ÅLIDO, sem explica√ß√µes adicionais.

MAPEAMENTO DE ITENS DO CHECKLIST POR ARQUIVO:

üîπ BLOCO 1 ‚Äì MATR√çCULA E CERTID√ïES (Itens 1 a 9):
- item1: Certid√µes (inteiro teor, situa√ß√£o jur√≠dica, √¥nus reais, a√ß√µes reipersecut√≥rias) + Contrato
- item2: Nova Matr√≠cula (requisitos Art. 176, ¬ß 1¬∫, II da Lei 6.015/1973)
- item3: Matr√≠cula + Certid√µes SPU/Munic√≠pio (dominialidade)
- item4: Certid√£o RIP + Matr√≠cula (terrenos foreiros √† Uni√£o)
- item5: Matr√≠cula + Certid√£o de √înus Reais (√¥nus sobre im√≥vel)
- item6: Contrato + Termo de Autoriza√ß√£o (cancelamento de √¥nus)
- item7: Contrato + Matr√≠cula (qualifica√ß√£o propriet√°rios)
- item8: Matr√≠cula (inscri√ß√£o imobili√°ria/RIP)
- item9: Matr√≠cula + Certid√£o ITBI (inscri√ß√£o imobili√°ria)

üîπ BLOCO 2 ‚Äì T√çTULO E DOCUMENTA√á√ÉO (Itens T1 a T23):
- itemT1: Contrato (vias iguais)
- itemT2: Contrato (assinaturas, data, local)
- itemT3: Contrato + Matr√≠cula (descri√ß√£o e matr√≠cula)
- itemT4: Certid√£o ITBI + Contrato + Matr√≠cula (descri√ß√£o)
- itemT5: Certid√£o ITBI + Contrato (valores)
- itemT6: Certid√£o ITBI + Contrato (partes)
- itemT7: Termo quita√ß√£o + Contrato + Procura√ß√£o (assinaturas)
- itemT8: Contrato + Matr√≠cula (qualifica√ß√£o transmitentes)
- itemT9: Declara√ß√£o 1¬™ Aquisi√ß√£o (firma reconhecida)
- itemT10: Pacto antenupcial + Matr√≠cula (regime casamento)
- itemT11: Procura√ß√£o + Contrato (representa√ß√£o)
- itemT12: Atos Constitutivos + Contrato (PJ representa√ß√£o)
- itemT13: CND + Contrato (PJ d√©bitos)
- itemT14: CND espec√≠fica + Contrato (devedor CCB/m√∫tuo)
- itemT15: Certid√£o Junta + Contrato (PJ simplificada)
- itemT16: RG + CPF + Contrato (firma individual)
- itemT17: CAT SPU + Contrato (terreno foreiro Uni√£o)
- itemT18: Termo aforamento + Escritura (foreiro munic√≠pio)
- itemT19: Contrato + Matr√≠cula + Boletim (descri√ß√£o atualizada)
- itemT20: Procura√ß√£o (credor fiduci√°rio)
- itemT21: Contrato (requerimento gen√©rico)
- itemT22: Matr√≠cula + Certid√µes (averba√ß√µes necess√°rias)
- itemT23: Matr√≠cula + Leil√£o + Quita√ß√£o (consolida√ß√£o propriedade)

üö® REGRAS CR√çTICAS DE AN√ÅLISE:

1. **VERIFICA√á√ÉO OBRIGAT√ìRIA DE DOCUMENTOS:**
   - ANTES de analisar qualquer item, verifique se TODOS os documentos mapeados para aquele item est√£o dispon√≠veis
   - Se faltar QUALQUER documento obrigat√≥rio, responda "N/A" com justificativa explicando a aus√™ncia
   - NUNCA responda "Sim" se n√£o tiver todos os documentos necess√°rios

2. **CRIT√âRIOS DE RESPOSTA:**
   - "Sim": APENAS se o requisito est√° atendido E todos os documentos necess√°rios est√£o presentes
   - "N√£o": Se todos os documentos est√£o presentes mas o requisito n√£o est√° atendido
   - "N/A": Se falta algum documento obrigat√≥rio OU n√£o se aplica

3. **JUSTIFICATIVAS OBRIGAT√ìRIAS:**
   - Mencione TODOS os documentos que deveriam estar presentes para o item
   - Se faltar documento, liste especificamente quais est√£o faltando
   - Se responder "Sim", confirme que todos os documentos necess√°rios foram analisados

**EXEMPLO DE AN√ÅLISE CORRETA:**
- Item que requer "Contrato + Matr√≠cula" mas s√≥ tem "Matr√≠cula":
  ‚Üí Resposta: "N/A"
  ‚Üí Justificativa: "Documento 'Contrato' n√£o fornecido. Para an√°lise completa deste item s√£o necess√°rios: Contrato + Matr√≠cula. Dispon√≠vel apenas: Matr√≠cula."

FORMATO DE RESPOSTA OBRIGAT√ìRIO:
{
  "item1": "Sim/N√£o/N/A",
  "justificativa_item1": "Justificativa detalhada mencionando arquivos analisados",
  "item2": "Sim/N√£o/N/A",
  "justificativa_item2": "Justificativa detalhada mencionando arquivos analisados",
  ...
  "itemT1": "Sim/N√£o/N/A",
  "justificativa_itemT1": "Justificativa detalhada mencionando arquivos analisados",
  ...
  "itemT23": "Sim/N√£o/N/A",
  "justificativa_itemT23": "Justificativa detalhada mencionando arquivos analisados",
  "status_qualificacao": "aprovado/pendente/reprovado",
  "pontuacao_qualificacao": "0-100",
  "observacoes_gerais": "Observa√ß√µes sobre a an√°lise",
  "documentos_faltantes": "Lista de documentos que faltam",
  "problemas_identificados": "Principais problemas encontrados",
  "recomendacoes_especificas": "Recomenda√ß√µes espec√≠ficas"
}

DOCUMENTOS PARA AN√ÅLISE:
"""
    
    # OTIMIZA√á√ÉO DE TOKENS: Adicionar apenas se√ß√µes relevantes de cada documento
    for i, (doc, doc_type, filename) in enumerate(zip(documents, document_types, filenames)):
        prompt += f"\n=== DOCUMENTO {i+1}: {filename} (TIPO: {doc_type.upper()}) ===\n"
        
        # Extrair apenas se√ß√µes relevantes baseadas no tipo do documento (ECONOMIA DE TOKENS)
        relevant_content = extract_relevant_sections(doc, doc_type)
        prompt += relevant_content
        prompt += "\n"
    
    # Adicionar verifica√ß√£o pr√©via de documentos dispon√≠veis
    available_doc_types = set(document_types)
    prompt += f"\n\nüîç DOCUMENTOS DISPON√çVEIS PARA AN√ÅLISE: {', '.join(available_doc_types)}\n"
    
    # Adicionar mapeamento espec√≠fico de quais itens podem ser analisados
    prompt += "\nüö® ITENS QUE PODEM SER ANALISADOS (baseado nos documentos dispon√≠veis):\n"
    
    # Mapeamento CORRIGIDO de documentos necess√°rios por item (baseado na descri√ß√£o real de cada item)
    item_requirements = {
        # BLOCO 1 - MATR√çCULA E CERTID√ïES (Itens 1-9)
        'item1': ['certidao_inteiro_teor', 'certidao_situacao_juridica', 'certidao_onus_reais', 'certidao_acoes_reipersecutorias', 'contrato'],
        'item2': ['matricula'],  # Nova matr√≠cula
        'item3': ['contrato', 'matricula'],  # CORRIGIDO: "O contrato cont√©m a descri√ß√£o completa do im√≥vel e o n√∫mero da matr√≠cula?"
        'item4': ['certidao_rip', 'matricula'],
        'item5': ['matricula', 'certidao_onus_reais'],
        'item6': ['contrato', 'termo_autorizacao'],
        'item7': ['contrato', 'matricula'],
        'item8': ['matricula'],  # Matr√≠cula - inscri√ß√£o imobili√°ria
        'item9': ['matricula', 'certidao_itbi'],
        
        # BLOCO 2 - T√çTULO E DOCUMENTA√á√ÉO (Itens T1-T23)
        'itemT1': ['contrato'],  # Contrato em vias iguais
        'itemT2': ['contrato'],  # Assinaturas, data, local no contrato
        'itemT3': ['contrato', 'matricula'],  # CORRIGIDO: "O contrato cont√©m a descri√ß√£o completa..."
        'itemT4': ['certidao_itbi', 'contrato', 'matricula'],
        'itemT5': ['certidao_itbi', 'contrato'],
        'itemT6': ['certidao_itbi', 'contrato'],
        'itemT7': ['termo_quitacao', 'contrato', 'procuracao'],
        'itemT8': ['contrato', 'matricula'],  # CORRIGIDO: "Os transmitentes est√£o qualificados no t√≠tulo..."
        'itemT9': ['declaracao_primeira_aquisicao'],
        'itemT10': ['pacto_antenupcial', 'matricula'],
        'itemT11': ['procuracao', 'contrato'],
        'itemT12': ['atos_constitutivos', 'contrato'],
        'itemT13': ['cnd', 'contrato'],
        'itemT14': ['cnd', 'contrato'],
        'itemT15': ['certidao_junta_comercial', 'contrato'],
        'itemT16': ['documento_identidade', 'contrato'],
        'itemT17': ['cat_spu', 'contrato'],
        'itemT18': ['termo_aforamento', 'escritura'],
        'itemT19': ['contrato', 'matricula', 'boletim_cadastro_imobiliario'],  # CORRIGIDO: "O contrato indica a matr√≠cula..."
        'itemT20': ['procuracao'],
        'itemT21': ['contrato'],
        'itemT22': ['matricula'],  # CORRIGIDO: Averba√ß√µes na matr√≠cula
        'itemT23': ['matricula', 'leilao', 'termo_quitacao']
    }
    
    # Verificar quais itens podem ser analisados
    analyzable_items = []
    non_analyzable_items = []
    
    for item, required_docs in item_requirements.items():
        # Verificar se todos os documentos necess√°rios est√£o dispon√≠veis
        has_all_docs = all(any(req_doc in doc_type for doc_type in available_doc_types) for req_doc in required_docs)
        
        if has_all_docs:
            analyzable_items.append(item)
        else:
            missing_docs = [doc for doc in required_docs if not any(doc in dt for dt in available_doc_types)]
            non_analyzable_items.append(f"{item} (faltam: {', '.join(missing_docs)})")
    
    prompt += f"\n‚úÖ ITENS ANALIS√ÅVEIS: {', '.join(analyzable_items) if analyzable_items else 'NENHUM'}\n"
    prompt += f"\n‚ùå ITENS N√ÉO ANALIS√ÅVEIS: {', '.join(non_analyzable_items) if non_analyzable_items else 'NENHUM'}\n"
    
    prompt += "\nüö® INSTRU√á√ÉO FINAL OBRIGAT√ìRIA:\n"
    prompt += "- Para itens N√ÉO ANALIS√ÅVEIS: responda OBRIGATORIAMENTE 'N/A' com justificativa explicando quais documentos faltam\n"
    prompt += "- Para itens ANALIS√ÅVEIS: analise normalmente e responda Sim/N√£o conforme o caso\n"
    prompt += "\nAnalise cada item do checklist considerando APENAS os arquivos relacionados conforme o mapeamento acima."
    
    return prompt 
